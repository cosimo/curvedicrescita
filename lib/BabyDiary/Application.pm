package BabyDiary::Application;

$VERSION = '0.05';

use strict;
use warnings;
use base 'CGI::Application';

use Cache::FileCache;
use CGI::Application::Plugin::ConfigAuto;
use CGI::Application::Plugin::Forward;
use CGI::Application::Plugin::Redirect;
use CGI::Application::Plugin::Session;
use CGI::Carp 'fatalsToBrowser';

# Used to generate password hashes (sha1_hex) the same as those
# generated by MySQL's `sha1()' database function.
use Digest::SHA1;
use File::Spec ();

# Special application runmodes for articles/users sections
use BabyDiary::Application::Admin;
use BabyDiary::Application::Articles;
use BabyDiary::Application::Auth;
use BabyDiary::Application::Questions;
use BabyDiary::Application::Pregnancy;
use BabyDiary::Application::Search;
use BabyDiary::Application::Signup;
use BabyDiary::Application::StackTrace;
use BabyDiary::Application::UserPage;
use BabyDiary::Application::Users;

# Log-helper class
use Opera::Logger;

# Localization class
use BabyDiary::Locale;

# Model classes. High-level access to database tables
use BabyDiary::File::Articles;
use BabyDiary::File::Sessions;
use BabyDiary::File::Users;

# Presentation classes
use BabyDiary::View::Articles;

# Default expire time for sessions
use constant SESSION_EXPIRE_TIME => '+72h';

sub url_for {
    my ($self, $page) = @_;
   
    my $url = $self->config('cgi_root');
    $page =~ s{^/}{};
    $page =~ s{/$}{};
    $url .= '/' . $page;

    return $url;
}

{
    my $FILE_CACHE;

    sub cache {
        my $cache = $FILE_CACHE ||= Cache::FileCache->new();   
    }
}

# Used when adding/changing a new article
sub invalidate_cached_components {
    my ($self) = @_;

    return $self->cache->remove('cc-common-components');
}

#
# Define runmodes
#
sub setup
{
    my $self = shift;

    $self->start_mode('homepage');

    # Extract parameter from PATH_INFO automatically (C::A feature)
    # In this way, `/cgi-bin/MyOperaTest/start?mode=login' can be written as
    #              `/cgi-bin/MyOperaTest/start/login'.
    $self->mode_param(param=>'mode', path_info=>1);

    # Runmode for application errors
    $self->error_mode('default_error');

    # Define all run modes
    $self->run_modes(

        admin           => \&BabyDiary::Application::Admin::front_page,

        homepage        => \&BabyDiary::Application::homepage,
        articles        => \&BabyDiary::Application::default,

        article         => \&BabyDiary::Application::Articles::view,
        article_delete  => \&BabyDiary::Application::Articles::delete,
        article_modify  => \&BabyDiary::Application::Articles::modify,
        article_post    => \&BabyDiary::Application::Articles::post,

        article_search  => \&BabyDiary::Application::Articles::search,
        search          => \&BabyDiary::Application::Search::search_all,

		comment_delete  => \&BabyDiary::Application::Articles::delete_comment,
		comment_post    => \&BabyDiary::Application::Articles::post_comment,
 
        userpage_main   => \&BabyDiary::Application::UserPage::main,
        userpage_charts => \&BabyDiary::Application::UserPage::charts,
        new_baby        => \&BabyDiary::Application::UserPage::new_baby,

        ical            => \&BabyDiary::Application::Pregnancy::export_ical,

        question        => \&BabyDiary::Application::Questions::view,
        questions_latest=> \&BabyDiary::Application::Questions::latest,
        question_delete => \&BabyDiary::Application::Questions::delete,
        question_modify => \&BabyDiary::Application::Questions::modify,
        question_new    => \&BabyDiary::Application::Questions::new_form,
		question_post   => \&BabyDiary::Application::Questions::post,
		question_answer_post => \&BabyDiary::Application::Questions::post_answer,

        tags            => \&BabyDiary::Application::Search::tags,

        login           => \&BabyDiary::Application::Auth::login,
        logout          => \&BabyDiary::Application::Auth::logout,

        signup          => \&BabyDiary::Application::Signup::signup,
        signup_activation=>\&BabyDiary::Application::Signup::activation,
        signup_thanks   => \&BabyDiary::Application::Signup::thanks,

    );

    return;
}

#
# Set up the UTF-8 charset and inits the session
#
sub cgiapp_init
{
    my $self = shift;

    $self->tmpl_path($self->config('tmpl_path'));

    # Setup content charset as UTF-8
    $self->header_add(-type=>'text/html; charset=UTF-8');

    # Create or load session object
    $self->session_init();
}

#
# Default runmode. Works for most cases. Load template,
# load parameters, mix everything with energy. Add ice cubes. Voila'!
#
sub default
{
    my $self = $_[0];
    my $tmpl = $self->render_view();
    return $tmpl->output();
}

#
# How application "soft" errors should be handled
#
sub default_error
{
    my $self = $_[0];

    $self->log('error', 'Oops!');

    return $self->BabyDiary::Application::StackTrace::dump();
}

#
# Load localization messages
#
sub fill_messages
{
    my($self, $tmpl) = @_;
    my $locale = $self->locale;

    if (! $locale) {
        return;
    }

    my $locale_id = ref $locale;
    my $messages = $self->cache->get("messages-$locale_id");

    if (! $messages) {
        for my $msgid ($locale->all_messages())
        {
            # Replace TMPL_VARs inside language messages (this is an ugly solution,
            # but has much added flexibility in language messages writing)
            my $msg = $self->msg($msgid);

            # Create a "mini" template with only the message string and
            # resolve all tmpl_* tags inside it
            if($msg =~ m{tmpl_})
            {
                my $mini_tmpl = HTML::Template->new( scalarref=>\$msg, associate=>$tmpl );
                $msg = $mini_tmpl->output();
            }

            $messages->{"msg:$msgid"} = $msg;

        }

        $self->cache->set("messages-$locale_id" => $messages, "24 hours");

    }

    $tmpl->param(%{ $messages });

    return;
}

#
# Display a list of the latest articles with links
#
sub homepage
{
    my ($self) = @_;

    my $tmpl = $self->fill_params();

    $tmpl->param(
        page_title => $self->msg(q(Ultimi articoli pubblicati)),
        page_description => $self->msg(q(Questi sono gli ultimi articoli pubblicati su CurveDiCrescita)),
        menu_articles => 1
    );

    my $art = BabyDiary::File::Articles->new();
	
    # Make sure that only admins can see unpublished articles
    my $is_admin = $self->session->param('admin');
	my $admin_filter = $is_admin
		? {}
		: { published => {'<>', 0} }
		;

    # Front page article(s)
    my $main_art_list = $art->frontpage($admin_filter);
    if (! $main_art_list || ref $main_art_list ne 'ARRAY') {
        return $tmpl->output;
    }

    my $main_article = shift @{ $main_art_list };

    # Avoid duplicates of main article in other sections
    $admin_filter->{id} = { '<>', $main_article->{id} };

    # Most read, random, latest articles
    my $best = $art->best($admin_filter);

    $admin_filter->{id} = { 'NOT IN', [ map { $_->{id} } $main_article, @{ $best } ] };

    my $latest = $art->latest($admin_filter);
    my $random = $art->pick_randomly($admin_filter);

    my $show_ads = $tmpl->param('show_ads');

    for my $art ($main_article, @{$best}, @{$latest}, @{$random} ) {
        $art = BabyDiary::View::Articles::process($art, { show_ads => $show_ads });
    }

    # Process article data to be displayed
    $tmpl->param(
        main_articles_list => [ $main_article ],
        best_articles_list => $best,
        latest_articles_list => $latest,
        random_articles_list => $random,
    );

    return $tmpl->output();
}

sub go_back_or_forward {
	my ($self, $runmode) = @_;

	my $prev_url = $ENV{HTTP_REFERER} || $self->query->param('back');

	if (! $prev_url) {
		return $self->forward($runmode);
	}

	# Can't redirect to logout, it would automatically
	# logout all users that try to logout/login
	if ($prev_url =~ m{logout}) {
		$prev_url = '/';
	}

	$self->header_type('redirect');
	$self->header_props(-url => $prev_url);

	return;
}

#
# Load static params, like n. of registered users, ...
#
sub render_view
{
    my ($self, $tmpl_file) = @_;

    # Load template object
    my $tmpl;
    eval {
        $tmpl = $self->load_tmpl($tmpl_file,
            die_on_bad_params => 0,
            loop_context_vars => 1,
            cache => $self->config('tmpl_cache'),
        );
    };
    if ($@) {
        $self->log('error', 'Template [' . $tmpl_file . '] loading failed: ' . $@);
        $self->{__error__} = $@;
        die "fail\n";
    }

    $self->render_session($tmpl);
    $self->fill_messages($tmpl);
    $self->render_components($tmpl);
    $self->render_notice($tmpl);
    $self->render_menu($tmpl);

    return $tmpl;
}

# Was the previous bad name
*fill_params = *render_view;

sub render_components {
    my ($self, $tmpl) = @_;

    # If user is admin, set a special key
    my $is_admin = $self->session->param('admin');
    my $use_cache = not $is_admin;

    my $cache_key = q(cc-common-components);
    my $cache_time = q(24 hours);
    my $components;

    if ($use_cache) {
        $components = $self->cache->get($cache_key);
    }

    if (! $components) {

        $components = {
            # For articles-related sections, calculate also lists of latest/best articles
            articles_latest => $self->BabyDiary::Application::Articles::latest_n(10),
            articles_popular => $self->BabyDiary::Application::Articles::best_n(),

            # Latest/best questions
            questions_latest_html => $self->BabyDiary::Application::Questions::latest_n(10),
            questions_popular => $self->BabyDiary::Application::Questions::best_n(),

            articles_cloud => $self->BabyDiary::Application::Articles::cumulus_cloud(),
            questions_cloud => $self->BabyDiary::Application::Questions::cumulus_cloud(),

            # Automatic topics left sidebar
            topics => $self->BabyDiary::Application::Articles::topics(),
        };

        # Copyright string on footer
        my $start = 2008;
        my $year  = 1900 + (localtime())[5];
        if ($year > $start) {
            $year = $start . '-' . $year;
        }
        $components->{'copyright-year'} = $year;

        if ($use_cache) {
            $self->cache->set($cache_key, $components, $cache_time);
        }

    }

    $tmpl->param(%{ $components });

    # For the homepage, fetch last article id and render that
    my $runmode = $self->get_current_runmode();
    if ($runmode =~ m{homepage}) {
        $self->BabyDiary::Application::Articles::render($tmpl);
    }

    return;
}

sub render_menu {
    my ($self, $tmpl) = @_;

    # Set a param with the current runmode to show the correct selected menu-item
    my %param = ();

    my $rm = $self->get_current_runmode() || 'homepage';
    $param{mode} = $rm;
    $param{"menu_$rm"} = 1;

	if ($rm =~ m{^question}) {
		$param{menu_questions} = 1;
	}

    # Special menu items
    if ($rm eq 'article_search') {
        my $kw = $self->query->param('keyword');
		if (defined $kw &&
        	($kw eq 'faq' || $kw eq 'ostetrica' || $kw eq 'pediatra')
		) {
            $param{"menu_$kw"} = 1;
        }
    }
    elsif ($rm eq 'article') {
        my $id = $self->query->param('id');
        $param{"menu_art_$id"} = 1;
    }

    while (my ($key, $val) = each %param) {
        next unless defined $val;
        $tmpl->param($key => $val);
        $self->log('notice', 'render menu {', $key, '} => {', $val, '}');
    }

    return;
}

sub render_notice {
	my ($self, $tmpl) = @_;
	my $q = $self->query();

	if (my $msg = $q->param('notice_message')) {
		$tmpl->param(notice_message => $msg);
		$tmpl->param(notice_class => $q->param('notice_class') || 'notice');
	}

	return;
}

sub render_session {
    my ($self, $tmpl) = @_;

    # Add all calculated parameters to HTML::Template template object
    my %param;

    # Basic application parameters (cgi path, static resources path, ...)
    $param{mycgi_path} = $self->config('cgi_home');
    $param{cgi_root} = $self->config('cgi_root');

	$param{show_ads} = $self->config('show_ads');
	$param{show_translate_button} = $self->config('show_translate_button');
	$param{show_custom_search} = $self->config('show_custom_search');
    $param{www_path} = '/';

    # Calculate users count
    my $users = BabyDiary::File::Users->new();
    $param{users_count} = $users->count();
    $param{current_timestamp} = time();

    # Get other params from session
    my $session = $self->session();
    $param{logged} = $session->param('logged');
    $param{admin}  = $session->param('admin');
    $param{user}   = $session->param('user');

    # Get current username details into the template
    my $user = $users->get({where=>{username=>$param{user}}});
    if ($user) {
        for (keys %$user) {
            $tmpl->param('user_' . $_ => $user->{$_});
        }
    }

    $self->log('notice', 'Got session ' . $session);

    if($self->param('notice_title'))
    {
        $param{notice_title}   = $self->param('notice_title');
        $param{notice_message} = $self->param('notice_message');
        $param{notice_class}   = $self->param('notice_class');
    }

    while(my($key, $val) = each(%param))
    {
        # TODO remove debug
        next unless defined $val;
        $self->log('notice', 'render session {', $key, '} => {', $val, '}');
        $tmpl->param($key, $val);
    }

    return;
}

#
# Initialize Locale object to retrieve language messages
# Gets user language and loads those messages.
#
# TODO Browser negotiated HTTP-ACCEPT-LANGUAGE ?
#
sub locale
{
    my $self = $_[0];

    # Initialize locale handle
    if(! exists $self->{_locale} || ! defined $self->{_locale})
    {
        # Get user language from session or from user record, if possible
        my $curr_user = $self->session->param('user');
        my @lng       = ('it');

        if($curr_user)
        {
            my $users = BabyDiary::File::Users->new();
            my $rec   = $users->get({where=>{username=>$curr_user}});
            if($rec && $rec->{language})
            {
                $self->log('notice', 'User ', $curr_user, ' has language ', $rec->{language});
                unshift @lng, $rec->{language};
            }
        }

        $self->log('notice', 'Initializing locale with (', \@lng, ')');
        $self->{_locale} = BabyDiary::Locale->init(@lng);
    }

    return($self->{_locale});
}

#
# Takes care of initializing log channel and
# centralized logging, delegating to Opera::Logger class
#
sub log
{
    my($self, $level, @msg) = @_;
    my $logger;

    # Get log channel object
    if(! $self->{_log} )
    {
        $self->{_log} = Opera::Logger->new();
    }

    # Write information into the log channel
    if($logger = $self->{_log})
    {
        $logger->write($level, @msg);
    }

    return;
}

#
# Language message accessor
#
sub msg
{
    my($self, $msgid, @params) = @_;

    if(my $locale = $self->locale())
    {
        $msgid = $locale->maketext($msgid, @params);
    }

    return($msgid);
}

#
# Handles the session initialization and CGI::Session configuration,
# expire times. Sessions are stored inside MySQL server.
#
sub session_init
{
    my $self = $_[0];
    my $ses_tbl = BabyDiary::File::Sessions->new();

    #
    # Configure the CGI::Session behaviour
    #

    # Note: CGI::Session is automatically included
    # by CGI::Application::Plugin::Session
    CGI::Session->name('sid');

    # Check if we must remember the cookie/session
    my $expire_time = $self->query->param('remember')
        ? '+1M'                      # 1 Month
        : SESSION_EXPIRE_TIME();     # Default, 4 hours

    $self->log('notice', 'Expire time of session set to ', $expire_time);

    # Begin by changing cookie name, to hide
    $self->session_config(

        # Store sessions into mysql table
        CGI_SESSION_OPTIONS => [ "driver:sqlite;serializer:Storable", $self->query, {Handle=>$ses_tbl->dbh} ],

        # Session / cookie expire in 4 hours by default, or 1 month when user checks 'remember me!'
        DEFAULT_EXPIRY      => $expire_time,
        COOKIE_PARAMS       => {
            # Hide the CGI::Session nature of the cookie... for security reasons
            -name    => 'sid',
            -expires => $expire_time,
            -path    => '/',
        },

        # Don't automatically send cookie. It seems it gets sent every time...
        SEND_COOKIE => 1,
    );

    #---------------------------------------------------------------
    # FIXME REMOVE OR UNDERSTAND WHY EXISTING COOKIE IS IGNORED
    #
    # Check if client has already session id cookie
    my $cookie = $self->query->cookie('sid');

    # No cookie, so issue it now
    if(! defined $cookie || ! $cookie)
    {
        $self->log('notice', 'No cookie present. Sending it now.');
        $self->session_cookie();
    }
    else
    {
        $self->log('notice', 'Session cookie already present. SID=', $cookie);
        $self->session->load($cookie);
    }
    #---------------------------------------------------------------

    return;
}

sub redirect_with_user_message {
	my ($self, $message, $back_url, $class) = @_;

	$class ||= 'notice';

	my $prev_url = $ENV{HTTP_REFERER} || $self->url_for($back_url);
	$prev_url .=
		'?notice_message=' . CGI::escape($message) .
		'&notice_class=' . $class;

	$self->redirect($prev_url);

	return;
}

#
# Tells if the current user is actually logged in or it is
# an anonymous
#
sub user_logged
{
    my $self = $_[0];
    my $logged = 0;

    if(my $session = $self->session())
    {
        $logged = $session->param('logged');
    }

    return($logged);
}

sub user_notice
{
    my($self, $title, $msg) = @_;
    $title ||= $self->msg('Untitled notice');
    $msg   ||= $self->msg('Nothing to say?');

    $self->param(notice_title   => $title);
    $self->param(notice_message => $msg);
    $self->param(notice_class   => 'notice');
    return;
}

#
# Put out a user warning on the title section of the page.
# This is used to notice user of any warning/message.
#
sub user_warning
{
    my($self, $title, $msg, $class) = @_;
    $title ||= $self->msg('Untitled warning');
    $msg   ||= $self->msg('Nothing to say?');

    $self->param(notice_title   => $title);
    $self->param(notice_message => $msg);
    $self->param(notice_class   => $class || 'warning');

    return;
}

1;

